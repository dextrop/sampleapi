import os

DEFAULT_CLASS_FILE = "__init__.py"

SERIALZERS_MAIN_IMPORT_LINE = "from src.serializers.TABLE_NAMEserializer import MODEL_NAMESerializer"
MODELS_MAIN_IMPORT_LINE = "from src.models.TABLE_NAME import MODEL_NAME"

SERIALZERS_IMPORT_LINE = "from src.serializers import MODEL_NAMESerializer"
MODELS_IMPORT_LINE = "from src.models import MODEL_NAME"

SERIALIZER_FILE_PATH = "src/serializers/TABLE_NAMEserializer.py"
MODELS_FILE_PATH = "src/models/TABLE_NAME.py"

MODELS_CLASS_FILE_PATH = "src/models/__init__.py"
SERIALIZE_CLASS_FILE_PATH = "src/serializers/__init__.py"

def change_working_dir(path, error_message=None):
    if os.path.exists(path):
        os.chdir(path)
        return True
    else:
        if error_message == None:
            raise ValueError("change_dir: Path {} does not exits".format(path))
        else:
            raise ValueError(error_message)

def create_python_packages(packages_to_create):
    for package in packages_to_create:
        package_path = package
        os.system("mkdir {}".format(package_path))
        if package != "logs":
            os.system("touch {}/__init__.py".format(package_path))

def write_files(files_list):
    for file in files_list:
        open(file, "w").write(files_list[file])

def write_executable_script(script_files, base_folder="."):
    if "base_folder" == ".":
        base_folder = ""
    for script_file in script_files:
        if base_folder == ".":
            open(script_file, "w").write(script_files[script_file])
            os.system("chmod +x {}".format(script_file))
        else:
            open(base_folder + "/" + script_file, "w").write(script_files[script_file])
            os.system("chmod +x {}".format(base_folder + "/" + script_file))

def append_line_to_file(line, file_path):
    content_file = open(file_path, "r").read()
    if line not in content_file:
        if len(content_file) > 0:
            if content_file[-1] != "\n":
                open(file_path, "w").write(content_file + "\n" + line)
            else:
                open(file_path, "w").write(content_file + line + "\n")
        else:
            open(file_path, "w").write(line + "\n")

def validate_dict(dictObj, keys, raise_error=True, request_name = ""):
    if request_name == "":
        request_name = "request"
    for key in keys:
        if key not in dictObj:
            if raise_error:
                raise ValueError("Missing key '{}' in {}".format(key, request_name))

            return False
    return True


def check_if_folder_exits(folder, should_exits=True, error_message=None):
    if should_exits:
        check_condition = os.path.exists(folder)
        if error_message == None:
            error_message = "Folder doesn't exits.\n\t: path: " + folder
    else:
        check_condition = not os.path.exists(folder)
        if error_message == None:
            error_message = "Folder already exits.\n\t: path: " + folder

    if not check_condition:
        if error_message != None:
            raise ValueError(error_message)
        return False
    return True

def check_if_file_exits(filepath, should_exits=True, error_message=None):
    if should_exits:
        check_condition = os.path.exists(filepath)
        if error_message == None:
            error_message = "File doesn't exits.\n\t: path: " + filepath
    else:
        check_condition = not os.path.exists(filepath)
        if error_message == None:
            error_message = "File already exits.\n\t: path: " + filepath
    if not check_condition:
        if error_message:
            raise ValueError(error_message)
        return False
    return True

def check_if_line_exits_in_file(match_line, filepath):
    filedata = open(filepath, "r").read()
    for line in filedata.split("\n"):
        if match_line in line:
            return True
    return False

def replace_variables(text, fields_to_replace):
    """
    The function is created for Internal Development purpose
    fields_to_replace: {"model_name": current_model_name, "table_name": "current_table_name" }

    :param text: Main string text on which replace query will work.
    :param fields_to_replace: dict of find_key to replace_key mapping.

    :return: Replaced String.
    """
    for key in fields_to_replace:
        text = text.replace(key.upper(), fields_to_replace[key])

    return text