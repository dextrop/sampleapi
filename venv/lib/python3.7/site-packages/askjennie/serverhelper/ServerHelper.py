import os, random, string, pyperclip
from askjennie.serverhelper.configs_struct import *

class ServerHelper():
    def __init__(self, args):
        self.args = args

    def create_nginx_config(self, type_project, domain=None, port=None, root=None, internal_port="9005"):
        if type_project == "ssl":
            config_https = DEFAULT_NGINX_CONFIG_HTTPS.replace("DOMAIN", domain).replace("ROOT", root)
            open("/etc/nginx/conf.d/https.conf", "a").write(config_https)
            return True

        elif type_project == "phpmyadmin":
            config_phpmyadmin = DEFAULT_NGINX_CONFIG_PHPMYADMIN.replace("PORT", port).replace("ROOT", root)
            open("/etc/nginx/conf.d/phpmyadmin.conf", "a").write(config_phpmyadmin)
            return True

        elif type_project == "django":
            if port == 443:
                config_django = DEFAULT_NGINX_CONFIG_DJANGO_SSL.replace("PORT", port).replace("DOMAIN", domain) \
                    .replace("INTERNAL_PORT", internal_port)
                open("/etc/nginx/conf.d/https.conf", "a").write(config_django)
            else:
                config_django = DEFAULT_NGINX_CONFIG_DJANGO_NORMAL.replace("PORT", port).replace("DOMAIN", domain)
                open("/etc/nginx/conf.d/{}.conf".format(root.replace("/", "_")), "a").write(config_django)
        elif type_project == "nginx-default":
            open("/etc/nginx/conf.d/{}.conf".format(domain), "w").write(
                NORMAL_NGINX_CONFIG.replace("SERVER_NAME", domain).
                    replace("ROOT", root).
                    replace("PORT", port)
            )
        else:
            open("/etc/nginx/conf.d/default.conf", "w").write(DEFAULT_NGINX_CONFIG)
            return True

    def change_mysql_password(self, mysqlpassword=None):
        password = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(8))
        if mysqlpassword != None:
            password = mysqlpassword

        command = MYSQL_CHANGE_PASSWORD_COMMAND.replace("MYSQL_PASSWORD", password)
        os.system(command)
        return password

    def get_all_properties(self, arguments):
        root = "/var/www/html"
        port = "93" + str(random.randint(11, 99))
        password = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(8))

        for argument in arguments:
            if argument[:2] == "--":
                argument_arr = argument[2:].split("=")
                if len(argument_arr) < 2:
                    raise ValueError("Invalid command configration " + argument)
                argument_name = argument_arr[0]
                argument_value = argument_arr[1]
                if argument_name == "root":
                    root = argument_value
                elif argument_name == "port":
                    port = argument_value
                elif argument_name == "password":
                    password = argument_value

        return root, port, password

    def setup_lemp(self, mysqlpassword):
        os.system("add-apt-repository universe")
        os.system("apt-get update")
        os.system("apt-get install nginx mysql-server php-fpm php-mysql php-mbstring php-gettext apache2-utils libmysqlclient-dev -y")
        os.system("ufw allow 'Nginx Full'")

        os.system("unlink /etc/nginx/sites-enabled/default")
        self.create_nginx_config(type_project="normal")

        os.system("service php-fpm7.2 start")
        mysqlPassword = self.change_mysql_password(mysqlpassword=mysqlpassword)

        os.system("systemctl reload nginx")
        print("Installed Nginx, MySQL, php \nMySQL Credentials"
              "\n\tuser: root"
              "\n\tpassword: " + mysqlPassword)

    def install_certbot(self):
        os.system("add-apt-repository ppa:certbot/certbot")
        os.system("apt-get update")
        os.system("apt-get install python-certbot-nginx")

    def install_phpmyadmin(self, root, port):
        os.chdir(path=root)
        os.system("wget https://files.phpmyadmin.net/phpMyAdmin/5.1.0/phpMyAdmin-5.1.0-all-languages.tar.gz")
        os.system("tar -xvf phpMyAdmin-5.1.0-all-languages.tar.gz")
        os.system("mv phpMyAdmin-5.1.0-all-languages phpmyadmin")
        os.system("rm -rf phpMyAdmin-5.1.0-all-languages.tar.gz")

        self.create_nginx_config(type_project="phpmyadmin", port=port, root=root)
        os.system("systemctl reload nginx")

    def create_uwsgi_config(self, project_name, root, internal_port):
        os.system("mkdir /etc/uwsgi/")
        config = DEFAULT_UWSGI.replace("PROJECT_NAME", root) \
            .replace("INTERNAL_PORT", internal_port).replace("PROJECT_NAME", project_name)
        open("/etc/uwsgi/{}.ini".format(project_name)).write(config)
        if not "/etc/systemd/system/uwsgi.service":
            open("/etc/systemd/system/uwsgi.service", "w").write(UWSGI_CONF)

        os.system("sudo systemctl start uwsgi")
        os.system("sudo systemctl enable uwsgi")

    def install_elastic_search(self):
        os.system(
            'echo "deb https://artifacts.elastic.co/packages/7.x/apt stable main" | sudo tee -a /etc/apt/sources.list.d/elastic-7.x.list')
        os.system('apt-get update')
        os.system('apt-get install elasticsearch')
        open('/etc/elasticsearch/elasticsearch.yml', "a").write("network.host: localhost")
        os.system("systemctl start elasticsearch")
        os.system("systemctl enable elasticsearch")

    def install_kibana(self):
        os.system("apt-get install kibana")
        os.system('systemctl enable kibana')
        os.system('systemctl start kibana')

    def install_elk(self):
        self.install_elastic_search()
        self.install_kibana()
        os.system("apt-get install logstash")


    @property
    def run(self):
        """
        sudo serverhelper setup lemp
        :return:
        """
        arguments = self.args
        if arguments[0] == "setup" and arguments[1] == "lemp":
            _, _, password = self.get_all_properties(self.args)
            self.setup_lemp(password)

        if arguments[0] == "setup" and arguments[1] == "ssh-git":
            if (len(arguments) < 3):
                raise ValueError("Email address not provided")
            email = arguments[2]
            os.system('ssh-keygen -t ed25519 -C "{}"'.format(email))
            os.system('eval "$(ssh-agent -s)"')
            os.system('ssh-add -K /root/.ssh/id_ed25519')

        elif arguments[0] == "install" and arguments[1] == "phpmyadmin":
            root, port, _ = self.get_all_properties(arguments)
            if not os.path.exists(root):
                os.system("mkdir root_folder")
            self.install_phpmyadmin(root, port)

        elif arguments[0] == "generate-ssl":
            self.install_certbot()
            if len(arguments) < 2:
                raise ValueError("Missing Domain Name")

            domain = arguments[1]
            root, _, _ = self.get_all_properties(arguments)
            os.system("certbot --nginx -d {}".format(domain))
            self.create_nginx_config(type_project="ssl", domain=domain, root=root)
            os.system("systemctl reload nginx")

        elif arguments[0] == "generate" and arguments[1] == "nginx-html":

            server_name = arguments[2]
            root = os.getcwd()
            _, port, _ = self.get_all_properties(arguments)
            self.create_nginx_config(type_project="nginx-default", domain=server_name, root=root, port=port)
            os.system("systemctl reload nginx")

        elif arguments[0] == "install" and arguments[1] == "elasticsearch":
            self.install_elastic_search()

        elif arguments[0] == "install" and arguments[1] == "kibana":
            self.install_kibana()

        elif arguments[0] == "install" and arguments[1] == "elk":
            self.install_elk()

        elif arguments[0] == "setup" and arguments[1] == "elk":
            if not os.path.exists("settings.py"):
                raise ValueError("Invalid Folder, Settings.py does not exits")
            os.system("pip3 install python-logstash")
            updated_settings = open("settings.py", "r").read().replace('''LOGGING = {
    'version': 1,
    'disable_existing_loggers': True,
    'formatters': {
        'json': {
            '()': 'pythonjsonlogger.jsonlogger.JsonFormatter',
            'fmt': '%(levelname)s %(asctime)s %(message)s',
        },
        'simple': {
            'format': '%(levelname)s %(asctime)s %(message)s'
        },
        'price': {
            '()': 'pythonjsonlogger.jsonlogger.JsonFormatter',
            'format': '%(message)s'
        },
    },
    'handlers': {
        'console': {
            'level': 'DEBUG',
            'class': 'logging.StreamHandler',
            'formatter': 'simple'
        },
        'filesystem': {
            'level': 'DEBUG',
            'formatter': 'json',
            'class': 'logging.handlers.TimedRotatingFileHandler',
            'filename': os.path.join(BASE_DIR, 'logs/server.log'),
            'when': 'D',
            'interval': 1
        },
    },
    'loggers': {
        'django': {
            'handlers': ['console', 'filesystem'],
            'level': 'DEBUG',
            'propagate': False,
        }
    }
}''', '''LOGGING = {
  'version': 1,
  'disable_existing_loggers': False,
  'formatters': {
      'simple': {
            'format': 'velname)s %(message)s'
        },
  },
  'handlers': {
        'console': {
            'level': 'INFO',
            'class': 'logging.StreamHandler',
            'formatter': 'simple'
        },
        'logstash': {
            'level': 'WARNING',
            'class': 'logstash.TCPLogstashHandler',
            'host': 'localhost',
            'port': 5959, # Default value: 5959
            'version': 1, # Version of logstash event schema. Default value: 0 (for backward compatibility of the library)
            'message_type': 'django',  # 'type' field in logstash message. Default value: 'logstash'.
            'fqdn': False, # Fully qualified domain name. Default value: false.
            'tags': ['django.request'], # list of tags. Default: None.
        },
  },
  'loggers': {
        'django.request': {
            'handlers': ['logstash'],
            'level': 'WARNING',
            'propagate': True,
        },
        'django': {
            'handlers': ['console'],
            'propagate': True,
        },
    }
}''')
            open("settings.py", "w").write(
                updated_settings
            )

        elif arguments[0] == "deploy" and arguments[1] == "django":
            if not os.path.exists("manage.py"):
                raise ValueError("Invalid Folder, Settings.py does not exits")
            _, port, _ = self.get_all_properties(arguments)
            root = os.getcwd()
            if len(arguments) < 3:
                raise ValueError("Project Name not found")
            project_name = arguments[3].replace(" ", "").replace("-", "").replace("_", "")
            os.system("pip3 install uwsgi")
            internal_port = "95" + str(random.randint(11, 99))
            self.create_nginx_config(type_project="django", port=port, root=root, internal_port=internal_port)
            self.create_uwsgi_config(project_name=project_name, root=root, internal_port=internal_port)
        else:
            raise ValueError("Unknown Command")


