CUSTOM_RESPONSE = '''from rest_framework.response import Response
from rest_framework.status import is_success, HTTP_200_OK, HTTP_400_BAD_REQUEST

class CustomResponse(Response):
	def __init__(self, message=None, code=HTTP_200_OK, payload=None, etype=None,
				 template_name=None, headers=None,
				 exception=False, content_type=None):
		data = {
			'status': True,
			'payload': payload,
			'message': message
			}

		if not is_success(code=code):
			data['status'] = False

			error_data = {
			'code' : code,
			}
			code = HTTP_400_BAD_REQUEST
			data['error'] = error_data
		super(CustomResponse, self).__init__(data=data, status=code, template_name=template_name, headers=headers, exception=exception, content_type=content_type)'''

CUSTOM_EXCEPTION_HANDLER = '''from rest_framework.views import exception_handler
from src.lib.customresponse import CustomResponse
from rest_framework.status import HTTP_500_INTERNAL_SERVER_ERROR, HTTP_501_NOT_IMPLEMENTED, HTTP_400_BAD_REQUEST

def custom_exception_handler(exc, context):
	"""
	Custom exception handler for Django Rest Framework that adds
	the `status_code` to the response and renames the `detail` key to `error`.
	"""
	response = exception_handler(exc, context)
	import traceback
	stack = traceback.format_exc()
	# logger.exception(stack)

	if response is not None:
		response =  CustomResponse(message=exc.detail, etype=exc.__class__.__name__, code=exc.status_code)

	else:
		message = None
		code = HTTP_501_NOT_IMPLEMENTED

		if exc.__class__.__name__ == 'DoesNotExist':
			code = HTTP_500_INTERNAL_SERVER_ERROR
			message = exc.message

		elif (exc.__class__.__name__ == 'KeyError') or (exc.__class__.__name__ == 'MultiValueDictKeyError'):
			code = HTTP_400_BAD_REQUEST
			try:
				message = 'Bad request must pass %s' % exc.message
			except Exception as e:
				message = 'Missing key in request data, please check'

		elif exc.__class__.__name__ == 'ValidationError':
			code = HTTP_400_BAD_REQUEST
			message = exc.message

		elif exc.__class__.__name__ == 'IntegrityError':
			code = HTTP_400_BAD_REQUEST
			message = exc[1]

		elif exc.__class__.__name__ == 'error':
			code = HTTP_500_INTERNAL_SERVER_ERROR
			message = 'socket error'

		else:
			code = HTTP_500_INTERNAL_SERVER_ERROR
			message = "Unhandled Exception"

		response =  CustomResponse(message=message, etype=exc.__class__.__name__, code=code)
	return response'''

LOGGING_HANDLER = '''import logging
class LoggingMixin(object):
    """
    Provides full logging of requests and responses
    """
    def __init__(self):
        self.logger = logging.getLogger('django')
        self.log_data = None

    def initial(self, request, *args, **kwargs):
        try:
            self.logger.debug({"request": request.data, "method": request.method, "endpoint": request.path})
        except:
            self.logger.debug({"request": dict(), "method": request.method, "endpoint": request.path})

        super(LoggingMixin, self).initial(request, *args, **kwargs)

    def finalize_response(self, request, response, *args, **kwargs):
        self.logger = logging.getLogger('django')
        self.logger.debug(response.data)
        return super(LoggingMixin, self).finalize_response(request, response, *args, **kwargs)
'''

DJANGO_BASE_AUTH_CLASS = '''from rest_framework import authentication
from rest_framework import exceptions

class TokenAuthentication(authentication.BaseAuthentication):
    def authenticate(self, request):
        # write your auth code here.
        return None

    def authenticate_header(self, request):
        # declare all your herders here
        return []'''

DJANGO_MODEL_AUTH_CLASS = '''from src.models import MODEL_NAME, MODEL_NAMEToken
from rest_framework import authentication
from rest_framework import exceptions

class TokenAuthentication(authentication.BaseAuthentication):
    def authenticate(self, request):
        _token = request.META.get("HTTP_TOKEN", False)
        if _token:
            try:
                tokens = MODEL_NAMEToken.objects.filter(access_token=_token)
                if tokens.count() < 1:
                    raise exceptions.AuthenticationFailed('Invalid access token')
                token = tokens[0]
            except Exception as e:
                raise exceptions.AuthenticationFailed('Invalid access token')
            user_id = token.user_id            
            user = MODEL_NAME.objects.get(_id=user_id._id)
            return (user, token)

    def authenticate_header(self, request):
        return ['token']'''

DJANGO_PERMISSION_CLASS = '''from rest_framework import permissions
from django.core.exceptions import ValidationError

HTTP_METHOD_POST        = 'POST'
HTTP_METHOD_GET         = 'GET'
HTTP_METHOD_OPTION      = 'OPTION'
HTTP_METHOD_PUT         = 'PUT'
HTTP_METHOD_HEAD        = 'HEAD'
HTTP_METHOD_DELETE      = 'DELETE'

class IsAuthenticatedOrCreate(permissions.BasePermission):
    SAFE_METHODS = [HTTP_METHOD_POST]
    def has_permission(self, request, view):
        return ( request.method in IsAuthenticatedOrCreate.SAFE_METHODS or request.user and request.user.is_authenticated() )


class IsAuthenticated(permissions.BasePermission):
    def has_permission(self, request, view):
        if (str(request.user) == "AnonymousUser"):
            raise ValidationError("Authentication credentials were not provided.")
        else:
            return ( request.user and request.user.is_authenticated() )
'''